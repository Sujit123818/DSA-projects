# DSA-projects
A project that is built using Data strucure and algorithm 
BigInt (Big Integers) in C++
Overview

C++ primitive data types have limits. A long long tops out at around 20 digits, which is useless once you step into serious computation—large factorials, Fibonacci numbers, cryptography-style math, or algorithmic experiments.

This project implements a custom BigInt data type in C++ that can handle integers of arbitrary length, well beyond built-in limits. The implementation is written from scratch using fundamental concepts—no external libraries, no shortcuts.

If you want to understand how big integers actually work under the hood, this is the point of the project.

Key Features

This BigInt implementation supports the following operations:

Core Arithmetic

Addition of two big integers

Subtraction of two big integers

Multiplication of two big integers

Division of two big integers

Modulo operation

Advanced Operations

Power of a big integer

Square root of a big integer (floor value)

Comparison between two big integers

Count number of digits

Pre/Post increment and decrement

Utility

Convert primitive integer to BigInt

Print BigInt in readable form

Applications Implemented

This project isn’t just about operations—it applies BigInt to real computational problems:

Fibonacci numbers up to 10,000 (even 100,000 with slower performance)

Factorial calculation up to 1,000

Catalan numbers up to 1,000

These problems are impossible to solve correctly using standard C++ integer types.

Approach & Design

Here’s how the BigInt is built:

Storage:

Numbers are stored using std::string

Digits are stored in reverse order for faster arithmetic operations

Addition & Subtraction:

Classic school-level digit-by-digit arithmetic

Carry and borrow handled manually

Multiplication:

Digit-wise multiplication followed by accumulation of partial results

Division & Modulo:

Long-division style approach adapted for string-based numbers

Efficiency Choices:

Reverse storage reduces unnecessary shifting

Operations are optimized for correctness first, speed second

This project prioritizes clarity and correctness, not black-box performance tricks.

Example Usage
BigInt a("1234567891234567891234");
BigInt b("987654321987654321");

BigInt sum = a + b;
BigInt product = a * b;
BigInt power = a.pow(5);

cout << "Sum: " << sum << endl;
cout << "Product: " << product << endl;
cout << "Power: " << power << endl;

Why This Project Matters

Shows deep understanding of data representation

Reinforces core algorithmic thinking

Useful for:

Competitive programming

Systems-level understanding

Academic projects

Interview discussions

Most people use BigInt libraries. This project shows you understand how they’re built.

Limitations

Let’s be honest:

Not optimized for cryptographic or industrial-scale workloads

No FFT-based multiplication

Performance drops with extremely large digit counts

That’s fine. This is a learning-focused, foundational implementation.

Future Improvements

Possible extensions if you want to push this further:

FFT-based multiplication

Negative number handling (if not already added)

Operator overloading polish

Performance benchmarking

Header-only version

Author

Sujit Singh
Computer Science Student
Interested in low-level systems, algorithms, and mathematical computation